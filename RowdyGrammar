
Rowdy

<TERMINAL>

ID					=> id;
CONSTANT		=> constant;
IF					=> "if";
ELSE				=> "else";
LOOP				=> "loop";
COLON				=> ":";
BREAK				=> "break";
BECOMES			=> "=";
PRINT				=> "print";
READ				=> "read";
COMMA				=> ",";
OR					=> "or";
AND					=> "and";
LESS				=> "<";
LESSEQUAL		=> "<=";
EQUAL				=> "==";
GREATEREQUAL	=> ">=";
GREATER			=> ">";
NOTEQUAL		=> "!=";
PLUS				=> "+";
MINUS				=> "-";
MULTIPLY		=> "*";
DIVIDE			=> "/";
OPENPAREN		=> "(";
CLOSEDPAREN	=> ")";
POW					=> "^";
MOD					=> "%";

CAST_STR		=> "string";
CAST_INT		=> "int";
CAST_BINT		=> "bigint";
CAST_SHRT		=> "short";
CAST_BYT		=> "byte";
CAST_LNG		=> "long";
CAST_BOL		=> "boolean";
CAST_OBJ		=> "object";
CAST_DBL		=> "double";
AS 					=> "as";

CONCAT			=> "concat";
FUNC				=> "func";
CALL				=> "$";
RETURN			=> "return";
ISSET				=> "isset";
ROUND				=> "round";
LCURLY			=> "{";
RCURLY			=> "}";
ARRAY				=> "array";
CONST				=> "const";
GLOBAL			=> "global";
NATIVE			=> "native";
DYNAMIC			=> "dynamic";
IMPORT			=> "import";

SUPER				=> "super";
THIS				=> "this";
PUBLIC			=> "public";
PRIVATE			=> "private";
IS					=> "is";
TEMP				=> "temp";
NEW					=> "new";
DOT					=> ".";
AT					=> "@";

<SPECIAL> 	=> ". ( ) ; + - * / != = >= <= < > : == , ^ % $ { } @";

<BEGIN>

// ********************************************* Program Start *************************************************

PROGRAM(FUNC NATIVE DYNAMIC IMPORT)		=> IMPORTS DEFINITION;
IMPORTS(IMPORT)  											=> IMPORT CONSTANT IMPORTS;
DEFINITION(FUNC NATIVE DYNAMIC CONST ID)				
																			=> FUNCTION* | STATEMENT* DEFINITION;

// ********************************************* Statements ****************************************************
STMT_BLOCK(LCURLY)										=> LCURLY STMT_LIST RCURLY;
STMT_LIST(	ID IF ELSE LOOP SUPER THIS
			BREAK PRINT READ CONST GLOBAL
			RETURN CALL IMPORT)							=> STATEMENT STMT_LIST;
			
STATEMENT(	ID IF LOOP IMPORT THIS GLOBAL
			BREAK PRINT READ CONST
			CONCAT RETURN CALL SUPER ROUND)								
																			=> 	IF_STMT* | LOOP_STMT* | ASSIGN_STMT* | BREAK_STMT* |
																				PRINT_STMT* | READ_STMT* | FUNC_CALL* | RETURN_STMT* |
																				IMPORT_SINGLE* | SUPER_CONSTRUCTOR*;

SUPER_CONSTRUCTOR(SUPER)					=> SUPER FUNC_BODY_EXPR;
IMPORT_SINGLE(IMPORT)							=> IMPORT CONSTANT;
IF_STMT(IF)												=> IF EXPRESSION STMT_BLOCK ELSE_IF_PART;
ELSE_IF_PART(ELSE)								=> ELSE ELSE_IF_CASE;
ELSE_IF_CASE(IF LCURLY)						=> IF_STMT* | STMT_BLOCK*;
LOOP_STMT(LOOP)										=> LOOP ID COLON STMT_BLOCK;	
ASSIGN_STMT(ID CONST THIS
			GLOBAL)	 										=> ID_MODIFIER* ID_ACCESS* ID BECOMES EXPRESSION;

ID_MODIFIER(CONST THIS)						=> CONST_OPT*;
ID_ACCESS(GLOBAL THIS)						=> GLOBAL_DEF* | THIS_REF*;
GLOBAL_DEF(GLOBAL)								=> GLOBAL;
THIS_REF(THIS)										=> THIS DOT;
CONST_OPT(CONST)									=> CONST;

BREAK_STMT(BREAK)									=> BREAK ID_OPTION;
ID_OPTION(ID)											=> ID;
PRINT_STMT(PRINT)									=> PRINT EXPRESSION EXPR_LIST;
READ_STMT(READ)										=> READ ID PARAMS_TAIL;
RETURN_STMT(RETURN)								=> RETURN EXPRESSION;

// ********************************************* Function *************************************************
NATIVE_FUNC_OPT(NATIVE)					=> NATIVE;
DYNAMIC_OPT(DYNAMIC)						=> DYNAMIC;
TEMP_FUNC_OPT(TEMP)							=> TEMP;

FUNC_CALL(CALL)									=> CALL THIS_REF ID_FUNC_REF;
FUNC_BODY_EXPR(OPENPAREN)				=> OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;
NEW_OBJ(NEW)										=> NEW ID_FUNC_REF;

FUNCTION_BODY(OPENPAREN)						=> OPENPAREN PARAMETERS CLOSEDPAREN INHERIT_OPT STMT_BLOCK;
INHERIT_OPT(COLON)									=> COLON ID;
FUNCTION(FUNC NATIVE DYNAMIC TEMP)	=> NATIVE_FUNC_OPT* DYNAMIC_OPT* FUNC ID FUNCTION_BODY;
ANONYMOUS_FUNC(FUNC TEMP)						=> TEMP_FUNC_OPT FUNC FUNCTION_BODY;

PARAMETERS(ID)											=> ID IS_OPTION PARAMS_TAIL;
PARAMS_TAIL(COMMA)									=> COMMA ID IS_OPTION PARAMS_TAIL;

ID_FUNC_REF(ID) 									=> ID FUNC_BODY_EXPR;
IS_OPTION(IS) 										=> IS ACCESS_MODIFIER;
OBJ_ACCESS(AT)					 					=> AT ID DOT ID_FUNC_REF;
ACCESS_MODIFIER(PRIVATE PUBLIC) 	=> PRIVATE_ACCESS* | PUBLIC_ACCESS*;
PRIVATE_ACCESS(PRIVATE) 					=> PRIVATE;
PUBLIC_ACCESS(PUBLIC) 						=> PUBLIC;

// ********************************************* Arrays ***************************************************

ARRAY_EXPR(ARRAY)									=> ARRAY OPENPAREN EXPRESSION ARRAY_BODY CLOSEDPAREN;
ARRAY_BODY(COMMA COLON)						=> ARRAY_LINEAR_BODY* | ARRAY_KEY_VALUE_BODY*;
ARRAY_LINEAR_BODY(COMMA) 					=> COMMA EXPRESSION ARRAY_LINEAR_BODY;
ARRAY_KEY_VALUE_BODY(COLON)				=> COLON EXPRESSION ARRAY_KEY_VALUE_BODY_TAIL;
ARRAY_KEY_VALUE_BODY_TAIL(COMMA)	=> COMMA EXPRESSION ARRAY_KEY_VALUE_BODY;


// ********************************************* Expressions **********************************************

EXPRESSION(	ID THIS MINUS OPENPAREN CONSTANT AS TEMP
			CONCAT CALL FUNC ISSET ARRAY ROUND AT)	=>  EXPRESSIONS CAST_AS;
												
EXPRESSIONS(ID THIS MINUS OPENPAREN CONSTANT ISSET TEMP
					CONCAT CALL FUNC ARRAY ROUND AT)		=>  BOOL_EXPR* | CONCAT_EXPR* | 
																									ANONYMOUS_FUNC* | ISSET_EXPR* |
																									ROUND_EXPR* | ARRAY_EXPR* | OBJ_ACCESS*;

CAST_AS(AS)																		=> AS CAST_OPT;
CAST_OPT(CAST_STR CAST_INT CAST_DBL 
	CAST_BINT CAST_BOL CAST_BYT 
	CAST_SHRT CAST_LNG)								=> CAST_STR_OPT* | CAST_BINT_OPT* | CAST_INT_OPT* | CAST_BOL_OPT* | 
																				CAST_BYT_OPT* | CAST_SHRT_OPT* | CAST_LNG_OPT* | CAST_DBL_OPT*;
CAST_DBL_OPT(CAST_DBL)							=> CAST_DBL;
CAST_OBJ_OPT(CAST_OBJ)							=> CAST_OBJ;
CAST_STR_OPT(CAST_STR)							=> CAST_STR;
CAST_BINT_OPT(CAST_BINT)						=> CAST_BINT;
CAST_INT_OPT(CAST_INT)							=> CAST_INT;
CAST_BOL_OPT(CAST_BOL)							=> CAST_BOL;
CAST_BYT_OPT(CAST_BYT)							=> CAST_BYT;
CAST_SHRT_OPT(CAST_SHRT)						=> CAST_SHRT;
CAST_LNG_OPT(CAST_LNG)							=> CAST_LNG;													

													
EXPR_LIST(COMMA)										=> COMMA EXPRESSION EXPR_LIST;

BOOL_EXPR(ID THIS MINUS OPENPAREN CONSTANT CALL)	=> BOOL_TERM BOOL_TERM_TAIL;													
ROUND_EXPR(ROUND)																	=> ROUND ID COMMA ARITHM_EXPR;
CONCAT_EXPR(CONCAT)																=> CONCAT EXPRESSION EXPR_LIST;
ISSET_EXPR(ISSET)																	=> ISSET ID;
													
BOOL_TERM (ID THIS MINUS OPENPAREN CONSTANT CALL)	=> BOOL_FACTOR BOOL_FACTOR_TAIL;
BOOL_TERM_TAIL (OR)																=> OR BOOL_TERM BOOL_TERM_TAIL;

BOOL_FACTOR (ID THIS CONSTANT MINUS OPENPAREN CALL)	=> ARITHM_EXPR RELATION_OPTION;
BOOL_FACTOR_TAIL (AND)															=> AND BOOL_FACTOR BOOL_FACTOR_TAIL;

ARITHM_EXPR (ID THIS CONSTANT MINUS OPENPAREN CALL)	=> TERM TERM_TAIL;
RELATION_OPTION(LESS LESSEQUAL EQUAL 
									GREATEREQUAL GREATER NOTEQUAL)		=> 	ARITHM_LESS* | ARITHM_LESSEQUAL* | ARITHM_EQUAL* |
																													ARITHM_GREATEREQUAL* | ARITHM_GREATER* | ARITHM_NOTEQUAL*;

ARITHM_LESS(LESS)										=> LESS ARITHM_EXPR;
ARITHM_LESSEQUAL(LESSEQUAL)					=> LESSEQUAL ARITHM_EXPR;
ARITHM_GREATEREQUAL(GREATEREQUAL)		=> GREATEREQUAL ARITHM_EXPR;
ARITHM_GREATER(GREATER)							=> GREATER ARITHM_EXPR;
ARITHM_EQUAL(EQUAL)									=> EQUAL ARITHM_EXPR;
ARITHM_NOTEQUAL(NOTEQUAL)						=> NOTEQUAL ARITHM_EXPR;

TERM(ID THIS CONSTANT MINUS OPENPAREN CALL)	=> FACTOR FACTOR_TAIL;
TERM_TAIL(PLUS MINUS)												=> TERM_PLUS* | TERM_MINUS*;
TERM_PLUS(PLUS)															=> PLUS TERM TERM_TAIL;
TERM_MINUS(MINUS)														=> MINUS TERM TERM_TAIL;

FACTOR(ID THIS CONSTANT MINUS OPENPAREN CALL)	=> FACTOR_MINUS* | ATOMIC* | PAREN_EXPR*;
FACTOR_MINUS(MINUS)														=> MINUS FACTOR;
FACTOR_TAIL(MULTIPLY DIVIDE MOD POW)					=> FACTOR_TAIL_MUL* | FACTOR_TAIL_DIV* | FACTOR_TAIL_MOD* | FACTOR_TAIL_POW*;

FACTOR_TAIL_MUL(MULTIPLY)					=> MULTIPLY FACTOR FACTOR_TAIL;
FACTOR_TAIL_DIV(DIVIDE)						=> DIVIDE FACTOR FACTOR_TAIL;
FACTOR_TAIL_MOD(MOD)							=> MOD FACTOR FACTOR_TAIL;
FACTOR_TAIL_POW(POW)							=> POW FACTOR FACTOR_TAIL;

PAREN_EXPR(OPENPAREN)							=> OPENPAREN EXPRESSION CLOSEDPAREN;

ATOMIC(ID THIS CONSTANT CALL)				=> ATOMIC_ID* | ATOMIC_CONST* | ATOMIC_FUNC_CALL*;
ATOMIC_ID(ID THIS)									=> THIS_REF ID;
ATOMIC_CONST(CONSTANT)							=> CONSTANT;
ATOMIC_FUNC_CALL(CALL)							=> FUNC_CALL;


