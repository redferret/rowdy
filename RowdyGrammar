
Rowdy

<TERMINAL>

ID => id;
CONSTANT => constant;
IF => "if";
ELSE => "else";
LOOP => "loop";
WHILE => "while";
COLON => ":";
BREAK => "break";
BECOMES => "=";
PRINT => "print";
READ => "read";
COMMA => ",";
OR => "or";
AND => "and";
LESS => "<";
LESSEQUAL => "<=";
EQUAL => "==";
GREATEREQUAL=> ">=";
GREATER => ">";
NOTEQUAL => "!=";
PLUS => "+";
MINUS => "-";
MULTIPLY => "*";
DIVIDE => "/";
OPENPAREN => "(";
CLOSEDPAREN => ")";
LSQUARE => "[";
RSQUARE => "]";
POW => "^";
MOD => "%";
INCREMENT => "++";
DECREMENT => "--";
COMP_ADD => "+=";
COMP_SUB => "-=";
COMP_MUL => "*=";
COMP_DIV => "/=";
CAST_STR => "string";
CAST_INT => "int";
CAST_BINT => "bigint";
CAST_SHRT => "short";
CAST_BYT => "byte";
CAST_LNG => "long";
CAST_BOL => "boolean";
CAST_DBL => "double";
AS => "as";

THROW => "throw";
TRY => "try";
CATCH => "catch";
CONCAT => "concat";
FUNC => "func";
CALL => "$";
RETURN => "return";
ISSET => "isset";
ROUND => "round";
LCURLY => "{";
RCURLY => "}";
CONST => "const";
GLOBAL => "global";
NATIVE => "native";
DYNAMIC => "dynamic";
STATIC => "static";
IMPORT => "import";

SUPER => "super";
THIS => "this";
PUBLIC => "public";
PRIVATE => "private";
CLASS => "class";
INHERITS => "inherits";
CONSTRUCTOR => "construct";
IS => "is";
TEMP => "temp";
NEW => "new";
DOT => ".";
AT => "&";
QUESTION => "?";

<SPECIAL> => ". ( ) ; + - * / != = >= <= < > : == , ^ % $ { } [ ] & ++ -- ? -= += *= /=";

<BEGIN>

// ********************************************* Program Start *************************************************

PROGRAM(FUNC NATIVE DYNAMIC STATIC IMPORT CONST PUBLIC PRIVATE) => IMPORTS DEFINITION;
IMPORTS(IMPORT) => SINGLE_IMPORT IMPORTS;
SINGLE_IMPORT(IMPORT) => IMPORT CONSTANT;
DEFINITION(FUNC NATIVE DYNAMIC STATIC THIS CALL
						CONST ID PUBLIC PRIVATE) => FUNCTION* | STATEMENT* | CLASS_DEF* DEFINITION;

// ********************************************* Statements ****************************************************
STMT_BLOCK(LCURLY) => LCURLY STMT_LIST RCURLY;
STMT_LIST(ID IF ELSE LOOP SUPER THIS WHILE
			BREAK PRINT READ CONST GLOBAL THROW TRY
			RETURN CALL IMPORT) => STATEMENT STMT_LIST;
			
STATEMENT(ID IF LOOP IMPORT THIS GLOBAL TRY
			BREAK PRINT READ CONST WHILE THROW
			CONCAT RETURN CALL SUPER ROUND) => 	IF_STMT* | LOOP_STMT* | ASSIGN_STMT* | BREAK_STMT* | WHILE_LOOP* |
																					PRINT_STMT* | READ_STMT* | FUNC_CALL* | RETURN_STMT* |
																					SINGLE_IMPORT* | SUPER_CONSTRUCTOR* | THROW_STMT* | TRY_CATCH*;

IF_STMT(IF) => IF EXPRESSION STMT_BLOCK ELSE_IF_PART;
ELSE_IF_PART(ELSE) => ELSE ELSE_IF_CASE;
ELSE_IF_CASE(IF LCURLY) => IF_STMT* | STMT_BLOCK*;
LOOP_STMT(LOOP) => LOOP ID COLON EXPRESSION STMT_BLOCK;	
WHILE_LOOP(WHILE) => WHILE EXPRESSION STMT_BLOCK;

ASSIGN_STMT(ID CONST THIS GLOBAL) => ID_MODIFIER REF_ACCESS ARRAY_ACCESS DOT_ATOMIC ASSIGN_VALUE;

ASSIGN_VALUE(BECOMES COMP_ADD COMP_SUB COMP_DIV COMP_MUL INCREMENT DECREMENT) => BECOMES_EXPR* | COMPOUND_ASSIGN* | INCREMENT_EXPR* | DECREMENT_EXPR*;
							
COMPOUND_ASSIGN(COMP_ADD COMP_SUB COMP_DIV COMP_MUL) => COMP_ADD_* | COMP_SUB_* | COMP_DIV_* | COMP_MUL_*;
COMP_ADD_(COMP_ADD) => COMP_ADD EXPRESSION;
COMP_SUB_(COMP_SUB) => COMP_SUB EXPRESSION;
COMP_MUL_(COMP_MUL) => COMP_MUL EXPRESSION;
COMP_DIV_(COMP_DIV) => COMP_DIV EXPRESSION;

BECOMES_EXPR(BECOMES) => BECOMES EXPRESSION;

ID_MODIFIER(CONST GLOBAL) => GLOBAL_DEF* | CONST_OPT*;
GLOBAL_DEF(GLOBAL) => GLOBAL;
CONST_OPT(CONST) => CONST;

BREAK_STMT(BREAK) => BREAK ID_OPTION;
ID_OPTION(ID) => ID;
PRINT_STMT(PRINT) => PRINT EXPRESSION EXPR_LIST;
READ_STMT(READ) => READ ID PARAMS_TAIL;
RETURN_STMT(RETURN) => RETURN EXPRESSION;
THROW_STMT(THROW) => THROW CONSTANT;
TRY_CATCH(TRY) => TRY STMT_BLOCK OPT_CATCH*;
OPT_CATCH(CATCH) => CATCH ID STMT_BLOCK;
// ********************************************* Functions *************************************************
FUNC_OPTS(NATIVE DYNAMIC STATIC) => NATIVE_FUNC_OPT* | DYNAMIC_OPT* | STATIC_OPT*;
NATIVE_FUNC_OPT(NATIVE) => NATIVE;
DYNAMIC_OPT(DYNAMIC) => DYNAMIC;
STATIC_OPT(STATIC) => STATIC;

FUNC_CALL(CALL) => CALL ATOMIC_ID FUNC_PARAMS DOT_ATOMIC ARRAY_PART FUNC_CALL_TAIL;
FUNC_CALL_TAIL(OPENPAREN) => FUNC_PARAMS DOT_ATOMIC ARRAY_PART FUNC_CALL_TAIL;
ARRAY_PART(LSQUARE) => ARRAY_ACCESS DOT_ATOMIC;
FUNC_PARAMS(OPENPAREN) => OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;

FUNCTION_BODY(OPENPAREN) => OPENPAREN PARAMETERS CLOSEDPAREN PRIVATE_SCOPE STMT_BLOCK;
PRIVATE_SCOPE(LESS) => LESS PARAMETERS GREATER;

FUNCTION(FUNC NATIVE DYNAMIC STATIC TEMP) => FUNC_OPTS FUNC ID FUNCTION_BODY;
ANONYMOUS_FUNC(FUNC) => FUNC FUNCTION_BODY;

PARAMETERS(ID) => ID PARAMS_TAIL;
PARAMS_TAIL(COMMA) => COMMA ID PARAMS_TAIL;

// ********************************************* Arrays ***************************************************

ARRAY_ACCESS(LSQUARE) => LSQUARE EXPRESSION RSQUARE ARRAY_ACCESS;

ARRAY_EXPR(LSQUARE) => LSQUARE EXPRESSION ARRAY_BODY RSQUARE;
ARRAY_BODY(COMMA) => COMMA EXPRESSION ARRAY_BODY;

MAP_EXPR(LCURLY) => LCURLY MAP_ELEMENT MAP_BODY RCURLY;
MAP_BODY(COMMA) => COMMA MAP_ELEMENT MAP_BODY;
MAP_ELEMENT(ID AT THIS MINUS OPENPAREN CONSTANT AS NEW
			CONCAT CALL FUNC ISSET LCURLY LSQUARE ROUND AT) => EXPRESSION COLON EXPRESSION;

// ****************************************** Classes / Objects *******************************************

CLASS_DEF(PUBLIC PRIVATE) => OBJECT_PRIVATE* | OBJECT_PUBLIC* CLASS ID INHERIT_OPT CLASS_BODY;
OBJECT_PRIVATE(PRIVATE) => PRIVATE;
OBJECT_PUBLIC(PUBLIC) => PUBLIC;
CONSTRUCTOR_METHOD(CONSTRUCTOR) => CONSTRUCTOR FUNCTION_BODY;
SUPER_CONSTRUCTOR(SUPER) => SUPER FUNC_PARAMS;
CLASS_BODY(LCURLY) => LCURLY CONSTRUCTOR_METHOD PUBLIC_MEMBERS PRIVATE_MEMBERS RCURLY;
PUBLIC_MEMBERS(PUBLIC) => PUBLIC COLON CLASS_DEFS;
PRIVATE_MEMBERS(PRIVATE) => PRIVATE COLON CLASS_DEFS;
CLASS_DEFS(FUNC NATIVE DYNAMIC 
						CONST ID) => FUNCTION* | ASSIGN_STMT* CLASS_DEFS;
INHERIT_OPT(INHERITS) => INHERITS ID;
DOT_ATOMIC(DOT) => DOT ATOMIC_ID;
REF_ACCESS(ID THIS) => ID_* | THIS_*;
THIS_(THIS) => THIS;
ID_(ID) => ID;
NEW_OBJ(NEW LSQUARE LCURLY) => OPT_NEW* OBJ_OR_ARRAY FUNC_PARAMS;
OPT_NEW(NEW) => NEW;
OBJ_OR_ARRAY(ID LCURLY LSQUARE) => ID_* | ARRAY_EXPR* | MAP_EXPR*;


// ********************************************* Expressions **********************************************

EXPRESSION(ID THIS MINUS OPENPAREN CONSTANT AS NEW IS
			CONCAT CALL FUNC ISSET LSQUARE LCURLY ROUND) =>  EXPRESSIONS CAST_AS;
												
EXPRESSIONS(ID THIS MINUS OPENPAREN CONSTANT ISSET NEW IS
					CONCAT CALL FUNC LSQUARE LCURLY ROUND) => NEW_OBJ* | BOOL_EXPR* | CONCAT_EXPR* |
																								ANONYMOUS_FUNC* | ISSET_EXPR* |
																								ROUND_EXPR* | NULL_DEFAULT*;

INCREMENT_EXPR(INCREMENT) => INCREMENT;
DECREMENT_EXPR(DECREMENT) => DECREMENT;
																								
EXPR_LIST(COMMA) => COMMA EXPRESSION EXPR_LIST;
																								
CAST_AS(AS) => AS CAST_OPT;
CAST_OPT(CAST_STR CAST_INT CAST_DBL 
	CAST_BINT CAST_BOL CAST_BYT 
	CAST_SHRT CAST_LNG) => 	CAST_STR_OPT* | CAST_BINT_OPT* | CAST_INT_OPT* | CAST_BOL_OPT* | 
																				CAST_BYT_OPT* | CAST_SHRT_OPT* | CAST_LNG_OPT* | CAST_DBL_OPT*;
CAST_DBL_OPT(CAST_DBL) => CAST_DBL;
CAST_STR_OPT(CAST_STR) => CAST_STR;
CAST_BINT_OPT(CAST_BINT) => CAST_BINT;
CAST_INT_OPT(CAST_INT) => CAST_INT;
CAST_BOL_OPT(CAST_BOL) => CAST_BOL;
CAST_BYT_OPT(CAST_BYT) => CAST_BYT;
CAST_SHRT_OPT(CAST_SHRT) => CAST_SHRT;
CAST_LNG_OPT(CAST_LNG) => CAST_LNG;													

NULL_DEFAULT(IS) => IS ATOMIC_ID QUESTION EXPRESSION;
BOOL_EXPR(ID THIS MINUS OPENPAREN CONSTANT CALL) => BOOL_TERM BOOL_TERM_TAIL;													
ROUND_EXPR(ROUND) => ROUND ID COMMA ARITHM_EXPR;
CONCAT_EXPR(CONCAT) => CONCAT EXPRESSION EXPR_LIST;
ISSET_EXPR(ISSET) => ISSET ID;

BOOL_TERM (ID THIS MINUS OPENPAREN CONSTANT CALL) => BOOL_FACTOR BOOL_FACTOR_TAIL;
BOOL_TERM_TAIL (OR) => OR BOOL_TERM BOOL_TERM_TAIL;

BOOL_FACTOR (ID THIS CONSTANT MINUS OPENPAREN CALL) => ARITHM_EXPR RELATION_OPTION;
BOOL_FACTOR_TAIL (AND) => AND BOOL_FACTOR BOOL_FACTOR_TAIL;

ARITHM_EXPR (ID THIS CONSTANT MINUS OPENPAREN CALL) => TERM TERM_TAIL;
RELATION_OPTION(LESS LESSEQUAL EQUAL 
									GREATEREQUAL GREATER NOTEQUAL) => 	ARITHM_LESS* | ARITHM_LESSEQUAL* | ARITHM_EQUAL* |
																																ARITHM_GREATEREQUAL* | ARITHM_GREATER* | ARITHM_NOTEQUAL*;

ARITHM_LESS(LESS) => LESS ARITHM_EXPR;
ARITHM_LESSEQUAL(LESSEQUAL) => LESSEQUAL ARITHM_EXPR;
ARITHM_GREATEREQUAL(GREATEREQUAL) => GREATEREQUAL ARITHM_EXPR;
ARITHM_GREATER(GREATER) => GREATER ARITHM_EXPR;
ARITHM_EQUAL(EQUAL) => EQUAL ARITHM_EXPR;
ARITHM_NOTEQUAL(NOTEQUAL) => NOTEQUAL ARITHM_EXPR;

TERM(ID THIS CONSTANT MINUS OPENPAREN CALL) => FACTOR FACTOR_TAIL;
TERM_TAIL(PLUS MINUS) => TERM_PLUS* | TERM_MINUS*;
TERM_PLUS(PLUS) => PLUS TERM TERM_TAIL;
TERM_MINUS(MINUS) => MINUS TERM TERM_TAIL;

FACTOR(ID THIS CONSTANT MINUS OPENPAREN CALL) => FACTOR_MINUS* | ATOMIC* | PAREN_EXPR*;
FACTOR_MINUS(MINUS) => MINUS FACTOR;
FACTOR_TAIL(MULTIPLY DIVIDE MOD POW) => FACTOR_TAIL_MUL* | FACTOR_TAIL_DIV* | FACTOR_TAIL_MOD* | FACTOR_TAIL_POW*;

FACTOR_TAIL_MUL(MULTIPLY) => MULTIPLY FACTOR FACTOR_TAIL;
FACTOR_TAIL_DIV(DIVIDE) => DIVIDE FACTOR FACTOR_TAIL;
FACTOR_TAIL_MOD(MOD) => MOD FACTOR FACTOR_TAIL;
FACTOR_TAIL_POW(POW) => POW FACTOR FACTOR_TAIL;

PAREN_EXPR(OPENPAREN) => OPENPAREN EXPRESSION CLOSEDPAREN;

ATOMIC(ID THIS CONSTANT CALL) => ATOMIC_ID* | ATOMIC_CONST* | ATOMIC_FUNC_CALL*;
ATOMIC_ID(ID THIS) => REF_ACCESS ARRAY_ACCESS POST_INC_DEC DOT_ATOMIC;
POST_INC_DEC(INCREMENT DECREMENT) => INCREMENT_EXPR* | DECREMENT_EXPR*;
ATOMIC_CONST(CONSTANT) => CONSTANT;
ATOMIC_FUNC_CALL(CALL) => FUNC_CALL;


