
Rowdy

<TERMINAL>

ID				=> id;
CONSTANT		=> constant;
IF				=> "if";
ELSE			=> "else";
LOOP			=> "loop";
COLON			=> ":";
BREAK			=> "break";
BECOMES			=> "=";
PRINT			=> "print";
READ			=> "read";
COMMA			=> ",";
OR				=> "or";
AND				=> "and";
LESS			=> "<";
LESSEQUAL		=> "<=";
EQUAL			=> "==";
GREATEREQUAL	=> ">=";
GREATER			=> ">";
NOTEQUAL		=> "!=";
PLUS			=> "+";
MINUS			=> "-";
MULTIPLY		=> "*";
DIVIDE			=> "/";
OPENPAREN		=> "(";
CLOSEDPAREN		=> ")";
POW				=> "^";
MOD				=> "%";

CAST_STR		=> "string";
CAST_INT		=> "int";
CAST_BINT		=> "bigint";
CAST_SHRT		=> "short";
CAST_BYT		=> "byte";
CAST_LNG		=> "long";
CAST_BOL		=> "boolean";
CAST_OBJ		=> "object";
CAST_DBL		=> "double";
AS 				=> "as";

CONCAT			=> "concat";
FUNC			=> "func";
CALL			=> "$";
RETURN			=> "return";
ISSET			=> "isset";
ROUND			=> "round";
LCURLY			=> "{";
RCURLY			=> "}";
THIS			=> "this";
ARRAY			=> "array";
CONST			=> "const";
GLOBAL			=> "global";
NATIVE			=> "native";
IMPORT			=> "import";

<SPECIAL> => ". ( ) ; + - * / != = >= <= < > : == , ^ % -> $ { }";

<BEGIN>

// ********************** Program Start **************************

PROGRAM(FUNC NATIVE IMPORT)					 	=> IMPORTS DEFINITION;
IMPORTS(IMPORT)  								=> IMPORT CONSTANT IMPORTS;
DEFINITION(FUNC NATIVE)							=> FUNCTION DEFINITION;

// ********************** Statements *****************************
STMT_BLOCK(LCURLY)								=> LCURLY STMT_LIST RCURLY;
STMT_LIST(	ID IF ELSE LOOP
			BREAK PRINT READ CONST
			RETURN CALL IMPORT)					=> STATEMENT STMT_LIST;
			
STATEMENT(	ID IF LOOP IMPORT THIS
			BREAK PRINT READ CONST
			CONCAT RETURN CALL
			ROUND)								=> 	IF_STMT* | LOOP_STMT* | ASSIGN_STMT* | BREAK_STMT* |
													PRINT_STMT* | READ_STMT* | FUNC_CALL* | RETURN_STMT* |
													IMPORT_SINGLE*;
IMPORT_SINGLE(IMPORT)		=> IMPORT CONSTANT;
IF_STMT(IF)					=> IF EXPRESSION STMT_BLOCK ELSE_PART;
ELSE_PART(ELSE)				=> ELSE STMT_BLOCK;
LOOP_STMT(LOOP)				=> LOOP ID COLON STMT_BLOCK;	
	
// TODO: Change CONST_OPT to ID_MODIFIER when the ticket is made
ASSIGN_STMT(ID CONST THIS
			GLOBAL)	 		=> CONST_OPT ID BECOMES EXPRESSION;

ID_MODIFIER(CONST THIS
	GLOBAL)					=> CONST_OPT* | GLOBAL_DEF* | THIS_REF*;
GLOBAL_DEF(GLOBAL)			=> GLOBAL;
THIS_REF(THIS)				=> THIS;
CONST_OPT(CONST)			=> CONST;

BREAK_STMT(BREAK)			=> BREAK ID_OPTION;
ID_OPTION(ID)				=> ID;
PRINT_STMT(PRINT)			=> PRINT EXPRESSION EXPR_LIST;
READ_STMT(READ)				=> READ ID PARAMS_TAIL;
RETURN_STMT(RETURN)			=> RETURN EXPRESSION;

// ********************** Function **************************
NATIVE_FUNC_OPT(NATIVE)		=> NATIVE;

// Replace part of this with FUNC_BODY_EXPR when #32 is being worked on
FUNC_CALL(CALL)				=> CALL ID OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;

// For the future relating to ticket #32 - Remove this comment when this ticket is closed
FUNC_BODY_EXPR(OPENPAREN)	=> OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;

FUNCTION_BODY(OPENPAREN)	=> OPENPAREN PARAMETERS CLOSEDPAREN STMT_BLOCK;
FUNCTION(FUNC NATIVE)		=> NATIVE_FUNC_OPT FUNC ID FUNCTION_BODY;
ANONYMOUS_FUNC(FUNC)		=> FUNC FUNCTION_BODY;

PARAMETERS(ID)				=> ID PARAMS_TAIL;
PARAMS_TAIL(COMMA)			=> COMMA ID PARAMS_TAIL;

// ********************** Arrays ****************************

ARRAY_EXPR(ARRAY)					=> ARRAY OPENPAREN EXPRESSION ARRAY_BODY CLOSEDPAREN;
ARRAY_BODY(COMMA COLON)				=> ARRAY_LINEAR_BODY* | ARRAY_KEY_VALUE_BODY*;
ARRAY_LINEAR_BODY(COMMA) 			=> COMMA EXPRESSION ARRAY_LINEAR_BODY;
ARRAY_KEY_VALUE_BODY(COLON)			=> COLON EXPRESSION ARRAY_KEY_VALUE_BODY_TAIL;
ARRAY_KEY_VALUE_BODY_TAIL(COMMA)	=> COMMA EXPRESSION ARRAY_KEY_VALUE_BODY;


// ********************** Expressions ***********************

EXPRESSION(	ID MINUS OPENPAREN CONSTANT AS
			CONCAT CALL FUNC ISSET ARRAY ROUND)	=>  EXPRESSIONS CAST_AS;
												
EXPRESSIONS(ID MINUS OPENPAREN CONSTANT ISSET
			CONCAT CALL FUNC ARRAY ROUND)		=>  BOOL_EXPR* | CONCAT_EXPR* | 
													ANONYMOUS_FUNC* | ISSET_EXPR* |
													ROUND_EXPR* | ARRAY_EXPR*;

CAST_AS(AS)										=> AS CAST_OPT;
CAST_OPT(CAST_STR CAST_INT CAST_DBL 
	CAST_BINT CAST_BOL CAST_BYT 
	CAST_SHRT CAST_LNG)							=> CAST_STR_OPT* | CAST_BINT_OPT* | CAST_INT_OPT* | CAST_BOL_OPT* | 
													CAST_BYT_OPT* | CAST_SHRT_OPT* | CAST_LNG_OPT* | CAST_DBL_OPT*;
CAST_DBL_OPT(CAST_DBL)							=> CAST_DBL;
CAST_OBJ_OPT(CAST_OBJ)							=> CAST_OBJ;
CAST_STR_OPT(CAST_STR)							=> CAST_STR;
CAST_BINT_OPT(CAST_BINT)						=> CAST_BINT;
CAST_INT_OPT(CAST_INT)							=> CAST_INT;
CAST_BOL_OPT(CAST_BOL)							=> CAST_BOL;
CAST_BYT_OPT(CAST_BYT)							=> CAST_BYT;
CAST_SHRT_OPT(CAST_SHRT)						=> CAST_SHRT;
CAST_LNG_OPT(CAST_LNG)							=> CAST_LNG;													

													
EXPR_LIST(COMMA)								=> COMMA EXPRESSION EXPR_LIST;

BOOL_EXPR(ID MINUS OPENPAREN CONSTANT CALL)		=> BOOL_TERM BOOL_TERM_TAIL;													
ROUND_EXPR(ROUND)								=> ROUND ID COMMA ARITHM_EXPR;
CONCAT_EXPR(CONCAT)								=> CONCAT EXPRESSION EXPR_LIST;
ISSET_EXPR(ISSET)								=> ISSET ID;
													
BOOL_TERM (ID MINUS OPENPAREN CONSTANT CALL)	=> BOOL_FACTOR BOOL_FACTOR_TAIL;
BOOL_TERM_TAIL (OR)								=> OR BOOL_TERM BOOL_TERM_TAIL;

BOOL_FACTOR (ID CONSTANT MINUS OPENPAREN CALL)	=> ARITHM_EXPR RELATION_OPTION;
BOOL_FACTOR_TAIL (AND)							=> AND BOOL_FACTOR BOOL_FACTOR_TAIL;

ARITHM_EXPR (ID CONSTANT MINUS OPENPAREN CALL)	=> TERM TERM_TAIL;
RELATION_OPTION(LESS LESSEQUAL EQUAL 
				GREATEREQUAL GREATER NOTEQUAL)	=> 	ARITHM_LESS* | ARITHM_LESSEQUAL* | ARITHM_EQUAL* |
													ARITHM_GREATEREQUAL* | ARITHM_GREATER* | ARITHM_NOTEQUAL*;

ARITHM_LESS(LESS)						=> LESS ARITHM_EXPR;
ARITHM_LESSEQUAL(LESSEQUAL)				=> LESSEQUAL ARITHM_EXPR;
ARITHM_GREATEREQUAL(GREATEREQUAL)		=> GREATEREQUAL ARITHM_EXPR;
ARITHM_GREATER(GREATER)					=> GREATER ARITHM_EXPR;
ARITHM_EQUAL(EQUAL)						=> EQUAL ARITHM_EXPR;
ARITHM_NOTEQUAL(NOTEQUAL)				=> NOTEQUAL ARITHM_EXPR;

TERM(ID CONSTANT MINUS OPENPAREN CALL)	=> FACTOR FACTOR_TAIL;
TERM_TAIL(PLUS MINUS)					=> TERM_PLUS* | TERM_MINUS*;
TERM_PLUS(PLUS)							=> PLUS TERM TERM_TAIL;
TERM_MINUS(MINUS)						=> MINUS TERM TERM_TAIL;

FACTOR(ID CONSTANT MINUS OPENPAREN CALL)=> FACTOR_MINUS* | ATOMIC* | PAREN_EXPR*;
FACTOR_MINUS(MINUS)						=> MINUS FACTOR;
FACTOR_TAIL(MULTIPLY DIVIDE MOD POW)	=> FACTOR_TAIL_MUL* | FACTOR_TAIL_DIV* | FACTOR_TAIL_MOD* | FACTOR_TAIL_POW*;

FACTOR_TAIL_MUL(MULTIPLY)				=> MULTIPLY FACTOR FACTOR_TAIL;
FACTOR_TAIL_DIV(DIVIDE)					=> DIVIDE FACTOR FACTOR_TAIL;
FACTOR_TAIL_MOD(MOD)					=> MOD FACTOR FACTOR_TAIL;
FACTOR_TAIL_POW(POW)					=> POW FACTOR FACTOR_TAIL;

PAREN_EXPR(OPENPAREN)					=> OPENPAREN EXPRESSION CLOSEDPAREN;

ATOMIC(ID CONSTANT CALL)				=> ATOMIC_ID* | ATOMIC_CONST* | ATOMIC_FUNC_CALL*;
ATOMIC_ID(ID)							=> ID;
ATOMIC_CONST(CONSTANT)					=> CONSTANT;
ATOMIC_FUNC_CALL(CALL)					=> FUNC_CALL;


