
Rowdy

<TERMINAL>

ID					=> id;
CONSTANT		=> constant;
IF					=> "if";
ELSE				=> "else";
LOOP				=> "loop";
COLON				=> ":";
BREAK				=> "break";
BECOMES			=> "=";
PRINT				=> "print";
READ				=> "read";
COMMA				=> ",";
OR					=> "or";
AND					=> "and";
LESS				=> "<";
LESSEQUAL		=> "<=";
EQUAL				=> "==";
GREATEREQUAL	=> ">=";
GREATER			=> ">";
NOTEQUAL		=> "!=";
PLUS				=> "+";
MINUS				=> "-";
MULTIPLY		=> "*";
DIVIDE			=> "/";
OPENPAREN		=> "(";
CLOSEDPAREN	=> ")";
LSQUARE			=> "[";
RSQUARE			=> "]";
POW					=> "^";
MOD					=> "%";
INCREMENT		=> "++";
DECREMENT		=> "--";
CAST_STR		=> "string";
CAST_INT		=> "int";
CAST_BINT		=> "bigint";
CAST_SHRT		=> "short";
CAST_BYT		=> "byte";
CAST_LNG		=> "long";
CAST_BOL		=> "boolean";
CAST_DBL		=> "double";
AS 					=> "as";

CONCAT			=> "concat";
FUNC				=> "func";
CALL				=> "$";
RETURN			=> "return";
ISSET				=> "isset";
ROUND				=> "round";
LCURLY			=> "{";
RCURLY			=> "}";
CONST				=> "const";
GLOBAL			=> "global";
NATIVE			=> "native";
DYNAMIC			=> "dynamic";
IMPORT			=> "import";

SUPER				=> "super";
THIS				=> "this";
PUBLIC			=> "public";
PRIVATE			=> "private";
CLASS				=> "class";
INHERITS		=> "inherits";
CONSTRUCTOR => "construct";
IS					=> "is";
TEMP				=> "temp";
NEW					=> "new";
DOT					=> ".";
AT					=> "&";

<SPECIAL> 	=> ". ( ) ; + - * / != = >= <= < > : == , ^ % $ { } [ ] & ++ --";

<BEGIN>

// ********************************************* Program Start *************************************************

PROGRAM(FUNC NATIVE DYNAMIC IMPORT CONST PUBLIC)		=> IMPORTS DEFINITION;
IMPORTS(IMPORT)  																		=> IMPORT CONSTANT IMPORTS;
DEFINITION(FUNC NATIVE DYNAMIC THIS CALL
						CONST ID PUBLIC PRIVATE)								=> FUNCTION* | STATEMENT* | CLASS_DEF* DEFINITION;

// ********************************************* Statements ****************************************************
STMT_BLOCK(LCURLY)										=> LCURLY STMT_LIST RCURLY;
STMT_LIST(ID IF ELSE LOOP SUPER THIS
			BREAK PRINT READ CONST GLOBAL
			RETURN CALL IMPORT)							=> STATEMENT STMT_LIST;
			
STATEMENT(ID IF LOOP IMPORT THIS GLOBAL
			BREAK PRINT READ CONST
			CONCAT RETURN CALL SUPER ROUND)	=> 	IF_STMT* | LOOP_STMT* | ASSIGN_STMT* | BREAK_STMT* |
																					PRINT_STMT* | READ_STMT* | FUNC_CALL* | RETURN_STMT* |
																					IMPORT_SINGLE* | SUPER_CONSTRUCTOR*;

IMPORT_SINGLE(IMPORT)							=> IMPORT CONSTANT;
IF_STMT(IF)												=> IF EXPRESSION STMT_BLOCK ELSE_IF_PART;
ELSE_IF_PART(ELSE)								=> ELSE ELSE_IF_CASE;
ELSE_IF_CASE(IF LCURLY)						=> IF_STMT* | STMT_BLOCK*;
LOOP_STMT(LOOP)										=> LOOP ID COLON STMT_BLOCK;	
ASSIGN_STMT(ID CONST THIS GLOBAL)	=> ID_MODIFIER REF_ACCESS ARRAY_ACCESS DOT_ATOMIC ASSIGN_VALUE;
ASSIGN_VALUE(BECOMES INCREMENT 
							DECREMENT)					=> INCREMENT_EXPR* | DECREMENT_EXPR* | BECOMES_EXPR*;
BECOMES_EXPR(BECOMES)							=> BECOMES EXPRESSION;
INCREMENT_EXPR(INCREMENT)					=> INCREMENT;
DECREMENT_EXPR(DECREMENT)					=> DECREMENT;

ID_MODIFIER(CONST GLOBAL)					=> GLOBAL_DEF* | CONST_OPT*;
GLOBAL_DEF(GLOBAL)								=> GLOBAL;
CONST_OPT(CONST)									=> CONST;

BREAK_STMT(BREAK)									=> BREAK ID_OPTION;
ID_OPTION(ID)											=> ID;
PRINT_STMT(PRINT)									=> PRINT EXPRESSION EXPR_LIST;
READ_STMT(READ)										=> READ ID PARAMS_TAIL;
RETURN_STMT(RETURN)								=> RETURN EXPRESSION;

// ********************************************* Function *************************************************
NATIVE_FUNC_OPT(NATIVE)					=> NATIVE;
DYNAMIC_OPT(DYNAMIC)						=> DYNAMIC; 
TEMP_FUNC_OPT(TEMP)							=> TEMP;

FUNC_CALL(CALL)									=> CALL ATOMIC_ID FUNC_BODY_EXPR DOT_ATOMIC ARRAY_PART FUNC_CALL_TAIL;
ARRAY_PART(LSQUARE) 						=> ARRAY_ACCESS DOT_ATOMIC;
FUNC_CALL_TAIL(OPENPAREN)				=> FUNC_BODY_EXPR DOT_ATOMIC ARRAY_PART FUNC_CALL_TAIL;

FUNC_BODY_EXPR(OPENPAREN)				=> OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;

FUNCTION_BODY(OPENPAREN)						=> OPENPAREN PARAMETERS CLOSEDPAREN STMT_BLOCK;

FUNCTION(FUNC NATIVE DYNAMIC TEMP)	=> NATIVE_FUNC_OPT DYNAMIC_OPT FUNC ID FUNCTION_BODY;
ANONYMOUS_FUNC(FUNC)								=> TEMP_FUNC_OPT FUNC FUNCTION_BODY;

PARAMETERS(ID)											=> ID PARAMS_TAIL;
PARAMS_TAIL(COMMA)									=> COMMA ID PARAMS_TAIL;

// ********************************************* Arrays ***************************************************

ARRAY_ACCESS(LSQUARE)				=> LSQUARE EXPRESSION RSQUARE ARRAY_ACCESS;

ARRAY_EXPR(LSQUARE)					=> LSQUARE EXPRESSION ARRAY_BODY RSQUARE;
ARRAY_BODY(COMMA)						=> COMMA EXPRESSION ARRAY_BODY;

MAP_EXPR(LCURLY)						=> LCURLY MAP_ELEMENT MAP_BODY RCURLY;
MAP_BODY(COMMA)							=> COMMA MAP_ELEMENT MAP_BODY;
MAP_ELEMENT(ID AT THIS MINUS OPENPAREN CONSTANT AS NEW
			CONCAT CALL FUNC ISSET LCURLY LSQUARE ROUND AT)	=> EXPRESSION COLON EXPRESSION;

// ****************************************** Classes / Objects *******************************************

CLASS_DEF(PUBLIC PRIVATE) 			=> OBJECT_PRIVATE* | OBJECT_PUBLIC* CLASS ID INHERIT_OPT CLASS_BODY;
OBJECT_PRIVATE(PRIVATE)					=> PRIVATE;
OBJECT_PUBLIC(PUBLIC)						=> PUBLIC;
CONSTRUCTOR_METHOD(CONSTRUCTOR)	=> CONSTRUCTOR FUNCTION_BODY;
SUPER_CONSTRUCTOR(SUPER)				=> SUPER FUNC_BODY_EXPR;
CLASS_BODY(LCURLY)							=> LCURLY CONSTRUCTOR_METHOD PUBLIC_MEMBERS PRIVATE_MEMBERS RCURLY;
PUBLIC_MEMBERS(PUBLIC)					=> PUBLIC COLON CLASS_DEFS;
PRIVATE_MEMBERS(PRIVATE)				=> PRIVATE COLON CLASS_DEFS;
CLASS_DEFS(FUNC NATIVE DYNAMIC 
						CONST ID) 					=> FUNCTION* | ASSIGN_STMT* CLASS_DEFS;
INHERIT_OPT(INHERITS)						=> INHERITS ID;
DOT_ATOMIC(DOT)									=> DOT ATOMIC_ID;
REF_ACCESS(ID THIS)							=> ID_* | THIS_*;
THIS_(THIS)											=> THIS;
ID_(ID)												  => ID;
NEW_OBJ(NEW)							  		=> NEW OBJ_OR_ARRAY FUNC_BODY_EXPR;
OBJ_OR_ARRAY(ID LCURLY LSQUARE) => ID_* | ARRAY_EXPR* | MAP_EXPR*;
// ********************************************* Expressions **********************************************

EXPRESSION(ID THIS MINUS OPENPAREN CONSTANT AS NEW
			CONCAT CALL FUNC ISSET LSQUARE ROUND)	=>  EXPRESSIONS CAST_AS;
												
EXPRESSIONS(ID THIS MINUS OPENPAREN CONSTANT ISSET NEW
					CONCAT CALL FUNC LSQUARE ROUND)		=>  BOOL_EXPR* | CONCAT_EXPR* | 
																													ANONYMOUS_FUNC* | ISSET_EXPR* |
																													ROUND_EXPR* | NEW_OBJ*;

CAST_AS(AS)													=> AS CAST_OPT;
CAST_OPT(CAST_STR CAST_INT CAST_DBL 
	CAST_BINT CAST_BOL CAST_BYT 
	CAST_SHRT CAST_LNG)								=> 	CAST_STR_OPT* | CAST_BINT_OPT* | CAST_INT_OPT* | CAST_BOL_OPT* | 
																				CAST_BYT_OPT* | CAST_SHRT_OPT* | CAST_LNG_OPT* | CAST_DBL_OPT*;
CAST_DBL_OPT(CAST_DBL)							=> CAST_DBL;
CAST_STR_OPT(CAST_STR)							=> CAST_STR;
CAST_BINT_OPT(CAST_BINT)						=> CAST_BINT;
CAST_INT_OPT(CAST_INT)							=> CAST_INT;
CAST_BOL_OPT(CAST_BOL)							=> CAST_BOL;
CAST_BYT_OPT(CAST_BYT)							=> CAST_BYT;
CAST_SHRT_OPT(CAST_SHRT)						=> CAST_SHRT;
CAST_LNG_OPT(CAST_LNG)							=> CAST_LNG;													


EXPR_LIST(COMMA)										=> COMMA EXPRESSION EXPR_LIST;

BOOL_EXPR(ID THIS MINUS OPENPAREN CONSTANT CALL LSQUARE) => BOOL_TERM BOOL_TERM_TAIL;													
ROUND_EXPR(ROUND)																				 => ROUND ID COMMA ARITHM_EXPR;
CONCAT_EXPR(CONCAT)																			 => CONCAT EXPRESSION EXPR_LIST;
ISSET_EXPR(ISSET)																				 => ISSET ID;

BOOL_TERM (ID THIS MINUS OPENPAREN CONSTANT CALL LSQUARE) => BOOL_FACTOR BOOL_FACTOR_TAIL;
BOOL_TERM_TAIL (OR)																				=> OR BOOL_TERM BOOL_TERM_TAIL;

BOOL_FACTOR (ID THIS CONSTANT MINUS OPENPAREN CALL LSQUARE)	=> ARITHM_EXPR RELATION_OPTION;
BOOL_FACTOR_TAIL (AND)																			=> AND BOOL_FACTOR BOOL_FACTOR_TAIL;

ARITHM_EXPR (ID THIS CONSTANT MINUS OPENPAREN CALL LSQUARE)	=> TERM TERM_TAIL;
RELATION_OPTION(LESS LESSEQUAL EQUAL 
									GREATEREQUAL GREATER NOTEQUAL)	  				=> 	ARITHM_LESS* | ARITHM_LESSEQUAL* | ARITHM_EQUAL* |
																																ARITHM_GREATEREQUAL* | ARITHM_GREATER* | ARITHM_NOTEQUAL*;

ARITHM_LESS(LESS)										=> LESS ARITHM_EXPR;
ARITHM_LESSEQUAL(LESSEQUAL)					=> LESSEQUAL ARITHM_EXPR;
ARITHM_GREATEREQUAL(GREATEREQUAL)		=> GREATEREQUAL ARITHM_EXPR;
ARITHM_GREATER(GREATER)							=> GREATER ARITHM_EXPR;
ARITHM_EQUAL(EQUAL)									=> EQUAL ARITHM_EXPR;
ARITHM_NOTEQUAL(NOTEQUAL)						=> NOTEQUAL ARITHM_EXPR;

TERM(ID THIS CONSTANT MINUS OPENPAREN CALL LSQUARE)	=> FACTOR FACTOR_TAIL;
TERM_TAIL(PLUS MINUS)																=> TERM_PLUS* | TERM_MINUS*;
TERM_PLUS(PLUS)																			=> PLUS TERM TERM_TAIL;
TERM_MINUS(MINUS)																		=> MINUS TERM TERM_TAIL;

FACTOR(ID THIS CONSTANT MINUS OPENPAREN CALL LSQUARE)	=> FACTOR_MINUS* | ATOMIC* | PAREN_EXPR*;
FACTOR_MINUS(MINUS)																		=> MINUS FACTOR;
FACTOR_TAIL(MULTIPLY DIVIDE MOD POW)									=> FACTOR_TAIL_MUL* | FACTOR_TAIL_DIV* | FACTOR_TAIL_MOD* | FACTOR_TAIL_POW*;

FACTOR_TAIL_MUL(MULTIPLY)					=> MULTIPLY FACTOR FACTOR_TAIL;
FACTOR_TAIL_DIV(DIVIDE)						=> DIVIDE FACTOR FACTOR_TAIL;
FACTOR_TAIL_MOD(MOD)							=> MOD FACTOR FACTOR_TAIL;
FACTOR_TAIL_POW(POW)							=> POW FACTOR FACTOR_TAIL;

PAREN_EXPR(OPENPAREN)							=> OPENPAREN EXPRESSION CLOSEDPAREN;

ATOMIC(ID THIS CONSTANT CALL LSQUARE) => ATOMIC_ID* | ATOMIC_CONST* | ATOMIC_FUNC_CALL*;
ATOMIC_ID(ID THIS LSQUARE)						=> REF_ACCESS* ARRAY_ACCESS DOT_ATOMIC;
ATOMIC_CONST(CONSTANT)								=> CONSTANT;
ATOMIC_FUNC_CALL(CALL)								=> FUNC_CALL;


