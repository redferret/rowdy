
Rowdy

<TERMINAL>

ID				=> id;
CONST			=> constant;
IF				=> "if";
ELSE			=> "else";
LOOP			=> "loop";
COLON			=> ":";
BREAK			=> "break";
BECOMES			=> "=";
PRINT			=> "print";
READ			=> "read";
COMMA			=> ",";
OR				=> "or";
AND				=> "and";
LESS			=> "<";
LESSEQUAL		=> "<=";
EQUAL			=> "==";
GREATEREQUAL	=> ">=";
GREATER			=> ">";
NOTEQUAL		=> "!=";
PLUS			=> "+";
MINUS			=> "-";
MULTIPLY		=> "*";
DIVIDE			=> "/";
OPENPAREN		=> "(";
CLOSEDPAREN		=> ")";
POW				=> "^";
MOD				=> "%";
CONCAT			=> "concat";
SLICE			=> "slice";
STRCMP			=> "strcmp";
FUNC			=> "func";
CALL			=> "->";
RETURN			=> "return";
ISSET			=> "isset";
ROUND			=> "round";
LCURLY			=> "{";
RCURLY			=> "}";
ARRAY			=> "array";
GET				=> "get";
DEL				=> "del";
PUT				=> "put";
CONST_DEF		=> "const";

<SPECIAL> => ". ( ) ; + - * / != = >= <= < > : == , ^ % -> { }";

<BEGIN>

PROGRAM(FUNC)									=> DEFINITION;
DEFINITION(FUNC)								=> FUNCTION DEFINITION;
STMT_BLOCK(LCURLY)								=> LCURLY STMT_LIST RCURLY;
STMT_LIST(	ID IF ELSE LOOP
			BREAK PRINT READ CONST_DEF
			RETURN CALL)						=> STATEMENT STMT_LIST;
			
STATEMENT(	ID IF LOOP
			BREAK PRINT READ CONST_DEF
			CONCAT SLICE STRCMP RETURN CALL
			ROUND)								=> 	IF_STMT* | LOOP_STMT* | ASSIGN_STMT* | BREAK_STMT* |
													PRINT_STMT* | READ_STMT* | FUNC_CALL* | RETURN_STMT*;
													
IF_STMT(IF)					=> IF EXPRESSION STMT_BLOCK ELSE_PART;
ELSE_PART(ELSE)				=> ELSE STMT_BLOCK;
LOOP_STMT(LOOP)				=> LOOP ID COLON STMT_BLOCK;		
ASSIGN_STMT(ID CONST_DEF)	=> CONST_OPT ID BECOMES EXPRESSION;
CONST_OPT(CONST_DEF)		=> CONST_DEF;
BREAK_STMT(BREAK)			=> BREAK ID_OPTION;
ID_OPTION(ID)				=> ID;
PRINT_STMT(PRINT)			=> PRINT EXPRESSION EXPR_LIST;
READ_STMT(READ)				=> READ ID PARAMS_TAIL;
RETURN_STMT(RETURN)			=> RETURN EXPRESSION;

FUNC_CALL(CALL)				=> CALL ID OPENPAREN EXPRESSION EXPR_LIST CLOSEDPAREN;
FUNCTION_BODY(OPENPAREN)	=> OPENPAREN PARAMETERS CLOSEDPAREN STMT_BLOCK;
FUNCTION(FUNC)				=> FUNC ID FUNCTION_BODY;
ANONYMOUS_FUNC(FUNC)		=> FUNC FUNCTION_BODY;

PARAMETERS(ID)			=> ID PARAMS_TAIL;
PARAMS_TAIL(COMMA)		=> COMMA ID PARAMS_TAIL;

ARRAY_EXPR(ARRAY)					=> ARRAY OPENPAREN EXPRESSION ARRAY_BODY CLOSEDPAREN;
ARRAY_BODY(COMMA COLON)				=> ARRAY_LINEAR_BODY* | ARRAY_KEY_VALUE_BODY*;
ARRAY_LINEAR_BODY(COMMA) 			=> COMMA EXPRESSION ARRAY_LINEAR_BODY;
ARRAY_KEY_VALUE_BODY(COLON)			=> COLON EXPRESSION ARRAY_KEY_VALUE_BODY_TAIL;
ARRAY_KEY_VALUE_BODY_TAIL(COMMA)	=> COMMA EXPRESSION ARRAY_KEY_VALUE_BODY;


EXPRESSION(	ID MINUS OPENPAREN CONST 
			CONCAT SLICE STRCMP CALL FUNC 
			ISSET ARRAY GET ROUND)				=> 	BOOL_TERM* BOOL_TERM_TAIL* | CONCAT_EXPR* | SLICE_EXPR* | 
													STRCMP_EXPR* | ANONYMOUS_FUNC* | ISSET_EXPR* |
													GET_EXPR* | ROUND_EXPR* | ARRAY_EXPR*;
EXPR_LIST(COMMA)		=> COMMA EXPRESSION EXPR_LIST;
													
ROUND_EXPR(ROUND)		=> ROUND ID COMMA ARITHM_EXPR;
GET_EXPR(GET)			=> GET OPENPAREN EXPRESSION COMMA EXPRESSION CLOSEDPAREN;
CONCAT_EXPR(CONCAT)		=> CONCAT EXPRESSION EXPR_LIST;
SLICE_EXPR(SLICE)		=> SLICE EXPRESSION COMMA ARITHM_EXPR COMMA ARITHM_EXPR;
STRCMP_EXPR(STRCMP)		=> STRCMP EXPRESSION COMMA EXPRESSION;
ISSET_EXPR(ISSET)		=> ISSET ID;
													
BOOL_TERM (ID MINUS OPENPAREN CONST CALL)		=> BOOL_FACTOR BOOL_FACTOR_TAIL;
BOOL_TERM_TAIL (OR)								=> OR BOOL_TERM BOOL_TERM_TAIL;

BOOL_FACTOR (ID CONST MINUS OPENPAREN CALL)		=> ARITHM_EXPR RELATION_OPTION;
BOOL_FACTOR_TAIL (AND)							=> AND BOOL_FACTOR BOOL_FACTOR_TAIL;

ARITHM_EXPR (ID CONST MINUS OPENPAREN CALL)		=> TERM TERM_TAIL;
RELATION_OPTION(LESS LESSEQUAL EQUAL 
				GREATEREQUAL GREATER NOTEQUAL)	=> 	ARITHM_LESS* | ARITHM_LESSEQUAL* | ARITHM_EQUAL* |
													ARITHM_GREATEREQUAL* | ARITHM_GREATER* | ARITHM_NOTEQUAL*;

ARITHM_LESS(LESS)					=> LESS ARITHM_EXPR;
ARITHM_LESSEQUAL(LESSEQUAL)			=> LESSEQUAL ARITHM_EXPR;
ARITHM_GREATEREQUAL(GREATEREQUAL)	=> GREATEREQUAL ARITHM_EXPR;
ARITHM_GREATER(GREATER)				=> GREATER ARITHM_EXPR;
ARITHM_EQUAL(EQUAL)					=> EQUAL ARITHM_EXPR;
ARITHM_NOTEQUAL(NOTEQUAL)			=> NOTEQUAL ARITHM_EXPR;

TERM(ID CONST MINUS OPENPAREN CALL)	=> FACTOR FACTOR_TAIL;
TERM_TAIL(PLUS MINUS)				=> TERM_PLUS* | TERM_MINUS*;
TERM_PLUS(PLUS)						=> PLUS TERM TERM_TAIL;
TERM_MINUS(MINUS)					=> MINUS TERM TERM_TAIL;

FACTOR(ID CONST MINUS OPENPAREN CALL)	=> FACTOR_MINUS* | ATOMIC* | PAREN_EXPR*;
FACTOR_MINUS(MINUS)						=> MINUS FACTOR;
FACTOR_TAIL(MULTIPLY DIVIDE MOD POW)	=> FACTOR_TAIL_MUL* | FACTOR_TAIL_DIV* | FACTOR_TAIL_MOD* | FACTOR_TAIL_POW*;

FACTOR_TAIL_MUL(MULTIPLY)	=> MULTIPLY FACTOR FACTOR_TAIL;
FACTOR_TAIL_DIV(DIVIDE)		=> DIVIDE FACTOR FACTOR_TAIL;
FACTOR_TAIL_MOD(MOD)		=> MOD FACTOR FACTOR_TAIL;
FACTOR_TAIL_POW(POW)		=> POW FACTOR FACTOR_TAIL;

PAREN_EXPR(OPENPAREN)	=> OPENPAREN EXPRESSION CLOSEDPAREN;

ATOMIC(ID CONST CALL)	=> ATOMIC_ID* | ATOMIC_CONST* | ATOMIC_FUNC_CALL*;
ATOMIC_ID(ID)			=> ID;
ATOMIC_CONST(CONST)		=> CONST;
ATOMIC_FUNC_CALL(CALL)	=> FUNC_CALL;







